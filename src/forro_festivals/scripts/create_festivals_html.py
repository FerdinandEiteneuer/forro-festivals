from collections import defaultdict
from datetime import datetime, timedelta
from typing import List
from urllib.parse import urlparse

from flask import Flask, render_template
import pycountry

from forro_festivals.config import static_folder, root_path_flask, DateFormats
from forro_festivals.models.event import Event
from forro_festivals.db.db_api import get_events_from_db


def create_festivals_html(template='festivals.html'):

    festival_data = create_festival_data()

    app = Flask(__name__, root_path=root_path_flask)

    # The below 3 lines are needed since I added url_for into the base.html
    app.config['SERVER_NAME'] = 'localhost:5000'
    app.config['APPLICATION_ROOT'] = '/'
    app.config['PREFERRED_URL_SCHEME'] = 'http'


    with app.app_context():
        festivals = render_template(template, data=festival_data)

    static_folder.mkdir(exist_ok=True)
    with open(f'{static_folder}/{template}', 'w') as file:
        file.write(festivals)


def get_current_events() -> List[Event]:
    events = get_events_from_db()

    cutoff = datetime.today() - timedelta(days=14)  # show some old festivals that recently happenend
    events = [event for event in events if event.validated and event.start > cutoff]
    events = sorted(events, key=lambda event: event.start)
    return events

def create_festival_data():
    events = get_current_events()
    festival_data = format_festival_data(events)
    return festival_data

def create_festival_data_short():
    return {
        event.id: format_event(event, include_link=False)
        for event in get_current_events()
    }


def ensure_https_scheme(url: str):
    """prepends https if no scheme is contained in the url.
    Reason: for instance, if url is www.google.de the actual link
    that is generated by the html is www.forro-festivals.com/www.google.de
    or localhost:5000/www.google.de if running locally. This problem
    goes away if we use a full url."""
    parsed_url = urlparse(url)
    if not parsed_url.scheme:
        return f'https://{url}'
    elif parsed_url.scheme not in ['http', 'https']:
        # If the scheme is not http or https, prepend https://
        return f"https://{url}"
    else:
        # If the URL already has a valid scheme (http or https), return it as is
        return url

def get_flag(event: Event):
    """On the main page, we want to show flags instead of written country names.
    This function maps each event.country to a flag."""
    if event.country == 'Jupiter':
        return 'ğŸª'  # Easteregg fÃ¼r kleine Miris

    translations = {
        'EspaÃ±a': 'Spain',
        'Deutschland': 'Germany',
        'Ã–sterreich': 'Austria',
        'Schweiz': 'Switzerland',
    }

    country = translations.get(event.country) or event.country

    try:
        return pycountry.countries.lookup(country).flag
    except LookupError:
        return event.country

def ws(n: int):
    """returns whitespace, n characters long."""
    return n*'&nbsp;'

def format_event(event: Event, include_link=True):
    start = event.start.strftime(DateFormats.dm)
    end = event.end.strftime(DateFormats.dm)

    link = ensure_https_scheme(event.link)
    html_link = f'<a href="{link}">{event.link_text}</a>'
    sold_out = 'ğŸ›‘' if event.sold_out else ''

    if include_link:
        festival = f'{event.city} {get_flag(event)} | {start} â€“ {end} | {html_link} {sold_out}'
    else:
        festival = f'{event.city} {get_flag(event)}, {start} â€“ {end}'


    return festival

def format_festival_data(events: List[Event]):
    year_month_events = defaultdict(list)
    for event in events:
        year_month = event.start.strftime('%B %Y')  # January 2025
        year_month_events[year_month].append(format_event(event))

    return dict(year_month_events)

def format_festival_data_short(events: List[Event]):
    return [
        format_event(event, include_link=False)
        for event in events
    ]

if __name__ == '__main__':
    create_festivals_html()
