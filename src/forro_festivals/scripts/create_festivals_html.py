from collections import defaultdict
from datetime import datetime, timedelta
from typing import List
from urllib.parse import urlparse

from flask import Flask, render_template
import pycountry

from forro_festivals.config import static_folder, root_path_flask, DateFormats
from forro_festivals.scripts.event import Event
from forro_festivals.scripts.db_api import get_events_from_db


def create_festivals_html(template='festivals.html'):

    festival_data = create_festival_data()

    app = Flask(__name__, root_path=root_path_flask)

    # The below 3 lines are needed since I added url_for into the base.html
    app.config['SERVER_NAME'] = 'localhost:5000'
    app.config['APPLICATION_ROOT'] = '/'
    app.config['PREFERRED_URL_SCHEME'] = 'http'


    with app.app_context():
        festivals = render_template(template, data=festival_data)

    static_folder.mkdir(exist_ok=True)
    with open(f'{static_folder}/{template}', 'w') as file:
        file.write(festivals)


def create_festival_data():
    events = get_events_from_db()

    cutoff = datetime.today() - timedelta(days=14)  # show some old festivals that recently happenend
    events = [event for event in events if event.validated and event.start > cutoff]
    events = sorted(events, key=lambda event: event.start)

    festival_data = format_festival_data(events)
    return festival_data

def ensure_https_scheme(url: str):
    """prepends https if no scheme is contained in the url.
    Reason: for instance, if url is www.google.de the actual link
    that is generated by the html is www.forro-festivals.com/www.google.de
    or localhost:5000/www.google.de if running locally. This problem
    goes away if we use a full url."""
    parsed_url = urlparse(url)
    if not parsed_url.scheme:
        return f'https://{url}'
    elif parsed_url.scheme not in ['http', 'https']:
        # If the scheme is not http or https, prepend https://
        return f"https://{url}"
    else:
        # If the URL already has a valid scheme (http or https), return it as is
        return url

def get_flag(event: Event):
    if event.country == 'Jupiter':
        return '🪐'  # Easteregg für kleine Miris

    try:
        return pycountry.countries.lookup(event.country).flag
    except LookupError:
        return event.country

def ws(n: int):
    """returns whitespace, n characters long"""
    return n*'&nbsp;'

def format_event(event: Event):
    start = event.start.strftime(DateFormats.dm)
    end = event.end.strftime(DateFormats.dm)

    link = ensure_https_scheme(event.link)
    html_link = f'<a href="{link}">{event.link_text}</a>'

    festival = f'{event.city} {get_flag(event)} | {start} – {end} | {html_link}'
    return festival

def format_festival_data(events: List[Event]):
    year_month_events = defaultdict(list)
    for event in events:
        year_month = event.start.strftime('%B %Y')  # January 2025
        year_month_events[year_month].append(format_event(event))

    return dict(year_month_events)



if __name__ == '__main__':
    create_festivals_html()
